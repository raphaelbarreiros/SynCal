# Status
Approved

# Story
As an engineer,
I want a Postgres-based job queue for the worker,
so that future sync tasks can run without extra infrastructure.

# Acceptance Criteria
1. `sync_jobs` table stores job id, calendar id, connector type, payload, status, tries, next_run_at, and last_error.
2. Worker claims jobs with `SELECT ... FOR UPDATE SKIP LOCKED`, marks them `in_progress`, and releases them on completion.
3. Failed jobs increment `tries`, compute next retry timestamp using exponential backoff (capped at 30 minutes), and remain queued.
4. Jobs are schedulable for testing via the standard `POST /jobs/schedule` endpoint (admin-authenticated) and/or a local dev script (e.g., `scripts/seed.ts`).

# Tasks / Subtasks
- [ ] Database schema and Prisma models (AC: 1)
  - [ ] Define `sync_job_status` enum and `sync_jobs` table fields in Prisma schema (`prisma/schema.prisma`) to match architecture spec; include indexes on `(status, next_run_at)` and pair lookup [Source: docs/architecture/database-schema.md#Database Schema]
  - [ ] Add `sync_job_logs` table for execution summaries; include index on `job_id` [Source: docs/architecture/database-schema.md#Database Schema]
  - [ ] Generate and apply initial migration; ensure default values (`status=pending`, `retry_count=0`, `max_retries=5`, `next_run_at=NOW()`) [Source: docs/architecture/database-schema.md#Database Schema]

- [ ] Worker job claim loop (AC: 2)
  - [ ] Implement a job consumer in `apps/worker/src/consumers/queue.ts` that selects the next runnable job using `FOR UPDATE SKIP LOCKED` within a transaction and sets status to `in_progress` [Source: docs/architecture/database-schema.md#Database Schema; docs/architecture/error-handling-strategy.md#Error Handling Patterns]
  - [ ] Execute work via pluggable executor (e.g., `apps/worker/src/executors/sync.ts`); on success, mark job `completed` and write `sync_job_logs` entry [Source: docs/architecture/source-tree.md#Source Tree; docs/architecture/database-schema.md#Database Schema]
  - [ ] Ensure multi-worker safety by keeping the claim+update inside one transaction; prefer SERIALIZABLE or REPEATABLE READ isolation via Prisma transaction [Source: docs/architecture/error-handling-strategy.md#Data Consistency]

- [ ] Retry and backoff policy (AC: 3)
  - [ ] On failure, increment `retry_count`, set status to `retrying`, and compute `next_run_at` using exponential backoff 1→2→4→8→16 minutes with cap at 30m; leave job queued until next run [Source: docs/architecture/error-handling-strategy.md#External API Errors]
  - [ ] After `max_retries` (default 5), mark job `failed` and emit an alert entry with summary (no secrets) [Source: docs/architecture/error-handling-strategy.md#Provider Quotas & 429 Handling]
  - [ ] Record outcome, processed/failed counts, and error summary in `sync_job_logs` [Source: docs/architecture/database-schema.md#Database Schema]

- [ ] Scheduling endpoint and dev script (AC: 4)
  - [ ] Implement `POST /jobs/schedule` Fastify route validating payload with Zod; require admin session cookie and accept optional `Idempotency-Key` header to avoid duplicates [Source: docs/architecture/rest-api-spec.md#/jobs/schedule; docs/architecture/error-handling-strategy.md#Data Consistency]
  - [ ] Insert one or more `pending` jobs with initial window and priority; return 202 Accepted [Source: docs/architecture/rest-api-spec.md#/jobs/schedule]
  - [ ] Add `scripts/seed.ts` helper that can call the schedule route to enqueue test jobs during local development [Source: docs/architecture/source-tree.md#Source Tree]

- [ ] Observability & logging
  - [ ] Use `pino` for structured logs including correlation/job IDs and service context; redact secrets [Source: docs/architecture/error-handling-strategy.md#Logging Standards]
  - [ ] Expose metrics via `prom-client` (e.g., claimed/completed/failed counters, execution duration histogram) [Source: docs/architecture/tech-stack.md#Tech Stack]

- [ ] Structure & repos alignment
  - [ ] Place worker code under `apps/worker/src/{consumers,executors,schedulers,telemetry}`; API route under `apps/api/src/app/jobs` [Source: docs/architecture/source-tree.md#Source Tree]
  - [ ] Prisma schema/migrations under `prisma/` and domain DTOs/utilities under `packages/core` as they emerge [Source: docs/architecture/source-tree.md#Source Tree]

- [ ] Tests (integration + unit) (AC: 1–4)
  - [ ] Unit: Backoff calculator returns expected sequence and caps at 30m; status transitions validated [Source: docs/architecture/error-handling-strategy.md#External API Errors]
  - [ ] Integration (API): `POST /jobs/schedule` returns 202 and inserts jobs; requires admin session [Source: docs/architecture/rest-api-spec.md#/jobs/schedule]
  - [ ] Integration (Worker): With multiple worker instances, only one claims a given job; completes and logs successfully [Source: docs/architecture/database-schema.md#Database Schema]
  - [ ] Integration (Retry): Simulate failures to verify retry_count increment, next_run_at scheduling, and terminal `failed` after max retries [Source: docs/architecture/error-handling-strategy.md#External API Errors]

# Dev Notes
- Previous Story Insights
  - 1.3 focused on portal shell and navigation; no direct coupling to job queue beyond future dashboard tiles for jobs/alerts [Source: docs/architecture/front-end-spec.md#Screen Specifications]

- Data Models
  - `sync_jobs` fields: `id`, `pair_id`, `connector_id`, `window_start`, `window_end`, `payload`, `status`, `priority`, `retry_count`, `max_retries`, `next_run_at`, `last_error`, timestamps; indexed by `(status, next_run_at)` [Source: docs/architecture/database-schema.md#Database Schema]
  - `sync_job_logs` captures execution summary: processed/failed counts, outcome, error summary [Source: docs/architecture/database-schema.md#Database Schema]

- API Specifications
  - `POST /jobs/schedule` schedules jobs for a pair/window, returns 202 on acceptance; API uses session cookie auth (`syn_session`) [Source: docs/architecture/rest-api-spec.md#/jobs/schedule; docs/architecture/rest-api-spec.md#components.securitySchemes.sessionCookie]
  - Optional list endpoints (`GET /jobs`) may be used later for dashboard status [Source: docs/architecture/rest-api-spec.md#/jobs]

- Component/Service Specifications
  - Worker consumer uses `SELECT ... FOR UPDATE SKIP LOCKED` for safe concurrent claims; updates job to `in_progress` atomically [Source: docs/architecture/database-schema.md#Database Schema]
  - Backoff policy: exponential with cap at 30 minutes; max 5 retries by default; upon exhaustion, mark `failed` and surface alert [Source: docs/architecture/error-handling-strategy.md#External API Errors]
  - Error model uses typed `AppError` hierarchy; map to status transitions and logs; API enforces idempotency via header for schedule [Source: docs/architecture/error-handling-strategy.md#General Approach; docs/architecture/error-handling-strategy.md#Data Consistency]

- File Locations
  - Worker: `apps/worker/src/consumers/queue.ts`, `apps/worker/src/executors/sync.ts`, `apps/worker/src/telemetry/metrics.ts` [Source: docs/architecture/source-tree.md#Source Tree]
  - API: `apps/api/src/app/jobs/schedule.ts` (Fastify route + Zod validation) [Source: docs/architecture/source-tree.md#Source Tree]
  - Prisma: `prisma/schema.prisma`, `prisma/migrations/*` [Source: docs/architecture/source-tree.md#Source Tree]

- Testing Requirements
  - Use Vitest for unit tests and Testcontainers Postgres for integration tests; simulate multi-worker concurrency and failure paths [Source: docs/architecture/test-strategy-and-standards.md#Integration Tests]
  - Coverage goals and pyramid per architecture; include edge cases and idempotency behavior [Source: docs/architecture/test-strategy-and-standards.md#Testing Philosophy]

- Technical Constraints
  - TypeScript 5.9, Node 22 LTS, Fastify 5.6 (API), Prisma 6.16, pino 9.10, prom-client 15.1 [Source: docs/architecture/tech-stack.md#Tech Stack]
  - Transactions via Prisma with SERIALIZABLE isolation for critical writes [Source: docs/architecture/error-handling-strategy.md#Data Consistency]

- Project Structure Notes
  - Keep queue logic in worker package and route code in API per monorepo structure; share DTOs/types via `packages/core` as they stabilize [Source: docs/architecture/source-tree.md#Source Tree]

## Testing
- API scheduling: `POST /jobs/schedule` returns 202 and inserts jobs tied to the provided pair/window; requires admin session cookie [Source: docs/architecture/rest-api-spec.md#/jobs/schedule]
- Worker claim/complete: Start 2 worker processes; ensure only one claims a job, status transitions to `completed`, and a log entry is written [Source: docs/architecture/database-schema.md#Database Schema]
- Retry path: Force executor to throw; verify `retry_count` increments, `next_run_at` matches backoff sequence (1,2,4,8,16 ≤ 30m), terminal `failed` after max retries [Source: docs/architecture/error-handling-strategy.md#External API Errors]
- Idempotency: Re-send schedule request with same `Idempotency-Key`; verify duplicates are not created [Source: docs/architecture/error-handling-strategy.md#Data Consistency]

# Change Log
| Date       | Version | Description                   | Author        |
|------------|---------|-------------------------------|---------------|
| 2025-09-18 | v0.1    | Initial draft (1.4)           | Scrum Master  |

# Dev Agent Record
## Agent Model Used

## Debug Log References

## Completion Notes List

## File List

# QA Results

